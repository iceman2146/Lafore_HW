// ex14_3.cpp
// реализует очередь в виде шаблона
// использует механизм исключений для обработки ошибок
#include <iostream>
using namespace std;
const int MAX = 3;
///////////////////////////////////////////////////////////
template <class Type>
class Queue
{
private:
	Type qu[MAX];       // массив произвольного типа
	int head;           // индекс начала массива (т. е.,
	                    // очереди. Отсюда будут удаляться
	                    // старые элементы)
	int tail;           // индекс хвоста очереди, куда будут
	                    // добавляться новые элементы
	int count;                // число элементов в очереди
public:
	class full { };           // классы исключений
	class empty { };
	//---------------------------------------------------------
	Queue()                   // конструктор
	{ head =-1; tail =-1; count = 0; }
	void put(Type var)        // добавление элемента в конец
	{
		if(count >= MAX)      // если очередь заполнена,
			throw full();     // выдать исключение
		qu[++tail] = var;     // сохранить элемент
		++count;
		if(tail >= MAX - 1)   // зациклить хвост 
			tail =-1;
	}
	//---------------------------------------------------------
	Type get()                  // удаление элемента из начала
	{
		if(count <= 0)          // если очередь пуста,
			throw empty();      // выдать исключение
		Type temp = qu[++head]; // получить элемент
		--count;
		if(head >= MAX - 1)     // зациклить начало
			head =-1;
		return temp;            // вернуть элемент
	}
};
///////////////////////////////////////////////////////////
int main()
{
	system("chcp 1251 > nul");

	Queue<float>q1;   // q1 - объект класса Queue<float>
	float data;       // элемент данных, получаемый от пользователя
	char choice = 'p';// 'x', 'p' или 'g'

	do                // цикл (введите 'x' для выхода)
	{
		try           // блок повторных попыток
		{
			cout << "\nВведите 'x' для выхода, 'p' для добавления, 'g' для выдачи:";
			cin >> choice;
			if(choice == 'p')
			{
				cout << "Введите значение:";
				cin >> data;
				q1.put(data);
			}
			if(choice == 'g')
				cout << "Data =" << q1.get() << endl;
		}             // конец блока повторных попыток

		catch(Queue<float>::full)
		{
			cout << "Ошибка: очередь заполнена." << endl;
		}
		catch(Queue<float>::empty)
		{
			cout << "Ошибка: очередь пуста." << endl;
		}
	}while(choice != 'x');

	return 0;
}                     // конец main()
